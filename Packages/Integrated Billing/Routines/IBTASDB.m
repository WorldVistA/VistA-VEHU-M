IBTASDB ;EDE/TPF - MAIN RTN FOR VTU VISTA TABLE UTILITY
 ;;2.0;INTEGRATED BILLING;**742**;;Build 36
 ;;Per VA Directive 6402, this routine should not be modified.
 ;
 Q
 ;
POST(RESULT,ARG) ;EP - GENERIC CALL FOR IBTASDB
 N COMPRES,FDAERROR,NOW,POSTFDA,POSTRESULT,PURLOGDT,PUTFDA,PUTRESULT,RTN,X,X1,X2
 ;
 S NOW=$$NOW^XLFDT
 S X1=$P(NOW,".")
 S X2=2  ;SHOULD BE 30 ON RELEASE. COULD BE A SITE PARAM
 D C^%DTC
 S PURLOGDT=X
 S RTN=$T(+0)
 S NAMESPACE=RTN_U_NOW_U_"DEBUG DUMP"
 S ^XTMP(NAMESPACE,0)=PURLOGDT_U_$P(NOW,".")_U_"VTU FILE UPDATE LOG"
 M ^XTMP(NAMESPACE,"ARG")=ARG
 ;
 D CONVERTTOFDA^IBTASDBUTL(.ARG,.POSTFDA,.PUTFDA,.FDAERROR)  ;CONVERT INCOMING ARG TO POSTFDA AND PUTFDA
 ;
 I '$D(PUTFDA),'$D(POSTFDA),$D(FDAERROR) D  Q  ;IF AN FDA ERROR THEN CAN'T DO CALLS ANYWAY
 .M COMPRES=FDAERROR
 .K RESULT
 .D JSON(.RESULT,.COMPRES)
 .M ^XTMP(NAMESPACE,"ARG","PUT RESULT")=RESULT
 ;
 K RESULT
 ;
 I $D(POSTFDA) D POSTADD(.POSTRESULT,.POSTFDA)
 M ^XTMP(NAMESPACE,"ARG","POSTADD RESULT")=RESULT
 ;
 I $D(PUTFDA) D PUT(.PUTRESULT,.PUTFDA)
 ;
 M COMPRES=POSTRESULT
 M COMPRES=PUTRESULT
 M COMPRES=FDAERROR
 ;
 D JSON(.RESULT,.COMPRES)
 ;
 M ^XTMP(NAMESPACE,"ARG","PUT RESULT")=RESULT
 ;
 Q
 ;
 ;POSTS VS PUTS
 ;
 ;POST - CREATES A NEW RECORD EVERY TIME, NO IEN (RESOURCE ID?) NEEDED BUT RETURNED AS A SUCCESS VALUE, FILE AND REQUIRED KEY FIELDS NEEDED
 ;PUT  - UPDATES AN EXISTING RECORD, .01 SEARCH STR REQUIRED, EDITABLE FIELDS ALLOWED
 ;DELETE - DELETE A RECORD - DISCUSSION HOW TO IMPLEMENT
 ;
 ;VISTA FILEMAN FILE UPDATE
 ;K ARG,RESULT D PUTTEST^IBTASDB(.ARG,1) D PUT^IBTASDB(.RESULT,.ARG)
 ;K RESULT D PUT^IBTASDB(.RESULT,.TESTARG)
PUT(RESULT,ARG) ;EP - EDIT EXISTING RECORD IN FM FILE
 N ARRAY,ARGRECORD,EXISTINGIEN,FINDRES,FINDRET,FINDERR,FILENUM,FIELDS,FLAGS
 N IEN,IENS,INDEX,PUTFDA,PUTFLAGS,PUTRES,RETNUMBER,SCREEN,TARGET,VALUE
 D DTNOLF^DICRW
 ;INPUT: ARG HAS A PSEUDO FDA STRUCTURE WHERE THE THREE SUBSCRIPTS OF AN FDA ARRAY ARE 'FUSED' INTO ONE SUBSCRIPT
 ;           ARG("FILENUMBER_RECORDNUMBER_FIELDNUMBER")=VALUE
 ;
 ;OUTPUT: JSON STATUS STRING
 ;
 ;IN A PUT WE NEED THE SPECIAL LOOKUP FIELD. IEN SPECIFIC EDIT IS NOT ALLOWED
 ;ARG(file_number,unique_rec_number,search_target)=target_string
 ;ARG(file_number,unique_rec_number,field_number)=NEW VALUE   ;IN PUT THE .01 FIELD COULD BE NEW VALUE NOT A SEARCH TARGET
 ;WARNING: IF THE .01 IS THE SAME IN THE INPUT ARG ARRAY OR CREATES DUPES IN THE FILE
 ;THE FILE^DIE CALL DOES NOT WARN YOU OR CARE DUPES ARE CREATED.
 ;THIS CAN CREATE A DUPLICATE RECORD IF YOU ARE NOT CAREFUL
 ;SET UP PUTFDA TO MAKE THE FILE^DIE CALL
 K FINDRES
 S FILENUM=0
 F  S FILENUM=$O(ARG(FILENUM)) Q:'FILENUM  D
 .S ARGRECORD=""
 .F  S ARGRECORD=$O(ARG(FILENUM,ARGRECORD)) Q:ARGRECORD=""  D
 ..I $G(ARG(FILENUM,ARGRECORD,.01))="@" D  Q
 ...S FINDRES("0^find_errors",ARGRECORD,"ARG array record")=$G(ARGRECORD)
 ...S TARGET=$G(ARG(FILENUM,ARGRECORD,.01))
 ...S TARGET=$S($G(TARGET)=+$G(TARGET):$G(TARGET),1:""""_$G(TARGET)_"""")
 ...S FINDRES("0^find_errors",ARGRECORD,".01")=$G(TARGET)
 ...S FINDRES("0^find_errors",ARGRECORD,"error_message")="@ found in .01 field. Use DELETE for deleting records."
 ..;
 ..S IENS=""                            ;NO SUBFILE SEARCH
 ..S FIELDS=""        ;NO FIELDS NEEDED FOR A LOOKUP FOR A FILE^DIE
 ..;
 ..K TARGET
 ..D LKPFLAGS^IBTASDBUTL(.FLAGS,FILENUM,ARGRECORD,.TARGET,.ARG,.FINDRES) ;ANALYZE DD OF FILE AND RETURN APPROPRIATE LOOKUP FLAGS
 ..;
 ..;                            ^DD("KEY","F",364.8,.01,49,1)=""           
 ..S INDEX=""       ;NEVER SEEMS TO BE NEEDED WHEN USING FLAGS="M" IN SIMPLE SEARCHES
 ..S RETNUMBER=3    ;HOW MANY "FOUND' RECORDS TO RETURN. ALLOW THREE SO WE CAN SEE IF POSSIBLE DUPES?
 ..;                 WHEN RETNUMBER=1 THE FIRST RECORD FOUND IS RETURNED
 ..S SCREEN=""        ;EQUILVALENT TO DIC("S")
 ..;
 ..;S TARGET=$G(ARG(FILENUM,ARGRECORD,.01,"search_target"))  ;NOT USING THIS AS A FIELD YET
 ..S:'$D(TARGET) TARGET=$G(ARG(FILENUM,ARGRECORD,.01))
 ..;
 ..I '$D(TARGET) D
 ...S FINDRES("0^find_errors",ARGRECORD,"ARG array record")=$G(ARGRECORD)
 ...;S TARGET=$S($G(TARGET)=+$G(TARGET):$G(TARGET),1:""""_$G(TARGET)_"""")
 ...S FINDRES("0^find_errors",ARGRECORD,".01")=$G(TARGET)
 ...S FINDRES("0^find_errors",ARGRECORD,"error_message")="ARG search_target not defined or null"
 ..;
 ..;CHECK FOR EXISTING ENTRY IN FILE
 ..K FINDRET,FINDERR
 ..;
 ..D FIND^DIC(FILENUM,IENS,FIELDS,FLAGS,.TARGET,RETNUMBER,INDEX,SCREEN,"","FINDRET","FINDERR")
 ..;
 ..;THIS IS A FIND^DIC ERROR
 ..I $D(FINDERR) D  Q
 ...S FINDRES("0^find_errors",ARGRECORD,"ARG array record")=$G(ARGRECORD)
 ...S TARGET=$G(TARGET,"undefined")
 ...S TARGET=$S($G(TARGET)=+$G(TARGET):$G(TARGET),1:""""_$G(TARGET)_"""")
 ...S FINDRES("0^find_errors",ARGRECORD,".01")=$G(TARGET)
 ...S FINDRES("0^find_errors",ARGRECORD,"error_message")=$G(FINDERR("DIERR",1))_" "_$TR($G(FINDERR("DIERR",1,"TEXT",1)),"""")
 ..;
 ..;THIS IS A POSSIBLE DUPLICATE CHECK ERROR FILE^DIE DOESN'T DETECT
 ..;THIS WILL OCCUR IF THE REQUESTER TRIED TO EDIT A RECORD INTO BEING A DUPE OF AN EXISTING RECORD
 ..;BEFORE THE CALL OR A DUPE OR ONE THIS CALL ALREADY EDITED.
 ..;
 ..I +$G(FINDRET("DILIST",0))>1 D  Q
 ...S FINDRES("0^find_errors",ARGRECORD,"ARG array record")=$G(ARGRECORD)
 ...S TARGET=$G(TARGET,"undefined")
 ...S TARGET=$S($G(TARGET)=+$G(TARGET):$G(TARGET),1:""""_$G(TARGET)_"""")
 ...S FINDRES("0^find_errors",ARGRECORD,".01")=$G(TARGET)
 ...S FINDRES("0^find_errors",ARGRECORD,"error_message")="ARG Search found multiple entries in "_$G(FILENUM)_", and can't resolve for editing."
 ..;
 ..;THE REQUESTER PASSED A .01 VALUE THAT CAN NOT BE FOUND AND THEREFORE CANNOT BE EDITED
 ..I +$G(FINDRET("DILIST",0))=0 D  Q
 ...S FINDRES("0^find_errors",ARGRECORD,"ARG array record")=$G(ARGRECORD)
 ...S TARGET=$G(TARGET,"undefined")
 ...S TARGET=$S($G(TARGET)=+$G(TARGET):$G(TARGET),1:""""_$G(TARGET)_"""")
 ...S FINDRES("0^find_errors",ARGRECORD,".01")=$G(TARGET)
 ...S FINDRES("0^find_errors",ARGRECORD,"error_message")="ARG search_target returned nothing for file "_$G(FILENUM)
 ..;
 ..S IEN=$G(FINDRET("DILIST",2,1))
 ..;S ARG(FILENUM,ARGRECORD,.01)=$G(ARG(FILENUM,ARGRECORD,.01,"search_target"))
 ..;K ARG(FILENUM,ARGRECORD,.01,"search_target")
 ..M PUTFDA(FILENUM,IEN_",")=ARG(FILENUM,ARGRECORD)
 ..;
 ..;ALTHOUGH THE TARGET STRING WAS FOUND WE NEED TO CHECK IF THE .01 FIELD IS LISTED IT  CANNOT BE CHANGED  TO CAUSE
 ..;A DUPLICATE
 ..;Q:$G(PUTFDA(FILENUM,IEN_",",.01))=""  ;IF THE SEARCH VALUE WAS FOUND AND THE CALLER WANTS TO EDIT THE .01 FIELD
 ..;S TARGET=PUTFDA(FILENUM,IEN_",",.01)
 ..;K FINDERR,FINDRET
 ..;D FIND^DIC(FILENUM,IENS,FIELDS,FLAGS,TARGET,RETNUMBER,INDEX,SCREEN,,"FINDRET","FINDERR")
 ..;I +$G(FINDRET("DILIST",0))>0 D  Q  ;IF NEW VALUE IS ALREADY THERE THEN THIS NEW ONE WILL BE A DUPE
 ..;.S EXISTINGIEN=FINDRET("DILIST",2,1)   ;IEN OF EXISTING RECORD
 ..;.Q:IEN=EXISTINGIEN
 ..;.K PUTFDA(FILENUM,IEN_",")
 ..;.S FINDRES("0^find_errors",ARGRECORD+.5,"ARG array record")=ARGRECORD
 ..;.S FINDRES("0^find_errors",ARGRECORD+.5,"error_message")="ARG will create duplicate entries in "_FILENUM
 ..;.;D ENCODE^XLFJSON("FINDRES","RESULT")
 ..;FROM HERE PLACE IN PUTFDA FOR LATER CALL TO FILE^DIE
 ..;END PUTFDA CREATION SECTION
 ..;
 ..;AT THIS POINT YOU SHOULD HAVE A LIST OF .01 SEARCH VALUES
 ..;THAT WERE FOUND WITH NO ISSUES AND THEY ARE IN PUTFDA
 ..I $D(FINDRES),'$D(PUTFDA) Q  ;D ENCODE^XLFJSON("FINDRES","RESULT") Q  ;NO FIND RESULTS TO EDIT AND ERRORS
 ..;Q:'$D(PUTFDA)   
 ..;
 ..S PUTFLAGS="SKET"  ;S = SAVE FDA, , K = LOCKING DONE BY API, E = DATA LIKE USER INPUT, T = ALL OR NOTHING
 ..K PUTERR
 ..D FILE^DIE(PUTFLAGS,"PUTFDA","PUTERR")
 ..;
 ..I $D(PUTERR) D
 ...;ADDERROR("DIERR",1)=701  ;DATABASE SERVER ERROR CODE
 ...;ADDERROR("DIERR",1,"TEXT",1)="The value 'FOR ONE' for field FIFTH FIELD in file ZZTPF TEST IBTASDB TEST FILE is not valid."
 ...;S RESULT(1)=$G(ADDERROR("DIERR",1))_" "_$G(ADDERROR("DIERR",1,"TEXT",1))
 ...S PUTRES("0^put_errors",ARGRECORD,"ARG array record")=ARGRECORD
 ...S PUTRES("0^put_errors",ARGRECORD,"error_message")=$G(PUTERR("DIERR",1))_" "_$TR($G(PUTERR("DIERR",1,"TEXT",1)),"""")
 ...S TARGET=$S($G(PUTFDA(FILENUM,IEN_",",.01))=+$G(TARGET):$G(PUTFDA(FILENUM,IEN_",",.01)),1:""""_$G(PUTFDA(FILENUM,IEN_",",.01))_"""")
 ...S PUTRES("0^put_errors",ARGRECORD,".01")=$G(TARGET)
 ..E  D
 ...S PUTRES("1^put_successes",ARGRECORD,"ARG array record")=ARGRECORD
 ...S PUTRES("1^put_successes",ARGRECORD,"file_number")=FILENUM
 ...S PUTRES("1^put_successes",ARGRECORD,".01")=$G(PUTFDA(FILENUM,IEN_",",.01))
 ...S PUTRES("1^put_successes",ARGRECORD,"file_number")=FILENUM
 ...;
 ;
 M PUTRES=FINDRES
 M RESULT=PUTRES
 ;D JSON(.RESULT,.PUTRES)
 ;D ENCODE^XLFJSON("PUTRES","RESULT")
 ;
 Q
 ;
 ;POST - CREATES A NEW RECORD EVERY TIME, NO IEN (RESOURCE ID) NEEDED (BUT RETURNED AS A SUCCESS VALUE?), FILE AND REQUIRED FIELDS NEEDED  
 ;TPF;EBILL-2515
 ;
 ;.S ARG(122000001,"+1,",.01)="NEW VLAUE FOR
 ;jOHNS' COMMENT:
 ;ARG("field.1")="data", where field.1 can be whatever you need it to be.
 ;The 277STAT array, in my opinion, is too verbose. but you can determine
 ;as you see it. there is a bug in the build of the array in that multiple records
 ;are not in sequential order, so they are loaded into VistA in the correct order. - technical debt issue
 ;
 ;K ARG D POSTTEST^IBTASDBTESTER(.ARG,5) D POST^IBTASDB(.RESULT,.ARG)
 ;K RESULT D POST^IBTASDB(.RESULT,.TESTARG)
POSTADD(RESULT,ARG) ;EP - CREATE NEW RECORD(S) IN FM FILE
 N ARGGREF,ARGRECORD,FILENUM,IENS,JSERR,POSTFDA,POSTERR,POSTIENS,POSTERR,POSTFLAGS,POSTRES,POSTRES,VALUE
 D DTNOLF^DICRW
 ;INPUT: ARG HAS A PSEUDO FDA STRUCTURE WHERE THE THREE SUBSCRIPTS OF AN FDA ARRAY ARE 'FUSED' INTO ONE SUBSCRIPT
 ;           ARG("FILENUMBER_RECORDNUMBER_FIELDNUMBER")=VALUE
 ;
 ;OUTPUT: JSON STATUS STRING
 ;
 I '$D(ARG) D  Q
 .S RESULT("status")="0^ARG array missing"
 ;
 ;I FILESECURITY IS ENABLED CHECK TO SEE IF FILENUMBER IS ALLOWED FOR THIS API
 ;Q:FILENUMBER NOT ALLOWED
 ;
 S POSTFLAGS="ES"  ;E = INCOMING DATA EXPECTED LIKE USER INPUT, S = KEEP FDA ARRAY
 ;
 K RESULT,POSTRES
 S IENS="+1,"
 S FILENUM=$O(ARG(""))
 S ARGRECORD=0
 F  S ARGRECORD=$O(ARG(FILENUM,ARGRECORD)) Q:'ARGRECORD  D
 .K POSTERR,POSTFDA,POSTIENS
 .M POSTFDA(FILENUM,IENS)=ARG(FILENUM,ARGRECORD)
 .;
 .;WHY IS THIS NOT GIVING ME A DUPE ERROR ON RUNNING THE SAME FDA AGAIN AND AGAIN???
 .;POSSIBLE BECAUSE I SET POSTIENS(1) TO GET THE NEW IEN BACK??
 .;
 .S POSTIENS(1)=""
 .;
 .D UPDATE^DIE(POSTFLAGS,"POSTFDA","POSTIENS","POSTERR")
 .I $D(POSTERR) D
 ..S POSTRES("0^post_errors",ARGRECORD,"ARG array record")=ARGRECORD
 ..S VALUE=$G(POSTFDA(364.8,"+1,",.01))
 ..S VALUE=$S($G(VALUE)=+$G(VALUE):$G(VALUE),1:""""_$G(VALUE)_"""")
 ..S POSTRES("0^post_errors",ARGRECORD,.01)=$G(VALUE)
 ..S POSTRES("0^post_errors",ARGRECORD,"error_message")=$G(POSTERR("DIERR",1))_" "_$TR($G(POSTERR("DIERR",1,"TEXT",1)),"""")
 .E  D
 ..;B:$G(DUZ)=561 "S+"
 ..S VALUE=$G(POSTFDA(364.8,"+1,",.01))
 ..S VALUE=$S($G(VALUE)=+$G(VALUE):$G(VALUE),1:""""_$G(VALUE)_"""")
 ..S POSTRES("1^post_successes",ARGRECORD,.01)=VALUE
 ..S POSTRES("1^post_successes",ARGRECORD,"ARG array record")=ARGRECORD
 ..S POSTRES("1^post_successes",ARGRECORD,"file_number")=FILENUM
 ..S POSTRES("1^post_successes",ARGRECORD,"newIEN")=POSTIENS(1)
 ;
 M RESULT=POSTRES
 ;MOVE THIS  IS END OF ARG PROCESSES TO INCLUDE ALL ERRORS FOR ALL RECORDS PASSED
 ;D JSON(.RESULT,.POSTRES)
 ;D ENCODE^XLFJSON("POSTRES","RESULT","JSERR")
 ;
 ;NEW NEEDS TESTING - DO WHAT ON JSON  ERROR?
 ;I $D(JSONERR) D
 ;.M RESULT=JSERROR
 ;
 Q
 ;
JSON(RESULT,POSTRES) ;EP
 N OLDRESTYPE,RESTYPE,REC,KEY,TEMP
 S RESULT="["
 S RESTYPE=""
 F  S RESTYPE=$O(POSTRES(RESTYPE)) Q:RESTYPE=""  D
 .S OLDRESTYPE=RESTYPE
 .;S RESULT=RESULT_"{""status"":"""_RESTYPE_"""},"
 .;
 .S REC=0
 .F  S REC=$O(POSTRES(RESTYPE,REC)) Q:REC=""  D
 ..S RESULT=RESULT_"{"
 ..;
 ..S KEY=""
 ..F  S KEY=$O(POSTRES(RESTYPE,REC,KEY)) Q:KEY=""  D
 ...;S RESULT=RESULT_""""_KEY_""":"_$S(KEY[("error"):"""",1:"")_POSTRES(RESTYPE,REC,KEY)_$S(KEY[("error"):"""",1:"")_$S(KEY'[("IEN"):",",1:"")
 ...S RESULT=RESULT_""""_KEY_""":"_$S(KEY[("error"):"""",1:"")_POSTRES(RESTYPE,REC,KEY)_$S(KEY[("error"):"""",1:"")
 ...I ($O(POSTRES(RESTYPE,REC,KEY))'="") S RESULT=RESULT_","
 ..I ($O(POSTRES(RESTYPE,REC))'="")!(($O(POSTRES(RESTYPE)))'="") S RESULT=RESULT_"},"
 ..E  S RESULT=RESULT_"}"
 S RESULT=RESULT_"]"
 S TEMP=RESULT
 K RESULT
 S RESULT(1)=TEMP
 ;
 Q
 ;
INC(COUNTER) ;EP - INCREMENT EMAIL COUNTER
 S COUNTER=$G(COUNTER)+1
 Q COUNTER
 ;
FINISH(RESULT) ; enclose message in '[ ]' when a Bundle
 N X
 I $G(RESULT(1))=""!($G(RESULT(1))="{}") S RESULT(1)="[{}]" Q
 S RESULT(1)="["_RESULT(1)
 S X=$O(RESULT("A"),-1)
 S RESULT(X)=RESULT(X)_"]"
 Q
 ;
 ;EXAMPLE USE OF 
 ;VISTAS1:VISTA>S IBSAVE("PCRiens",1,"ien")=78
 ;VISTAS1:VISTA>D ENCODE^XLFJSON("IBSAVE","RESULT")
 ;VISTAS1:VISTA>ZW RESULT
 ;RESULT(1)="{""PCRiens"":[{""ien"":78}]}"
 ;VISTAS1:VISTA>D FINISH^IBCEMSRI
 ;VISTAS1:VISTA>ZW RESULT
 ;RESULT(1)="[{""PCRiens"":[{""ien"":78}]}]"
