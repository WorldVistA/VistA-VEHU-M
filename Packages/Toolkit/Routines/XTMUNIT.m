XTMUNIT ;OAKLAND OIFO/JLI - MUNIT UNIT TESTING FOR M ROUTINES ;06/11/08  08:13
 ;;7.3;TOOLKIT;**81**;Apr 25, 1995;Build 13
 ;;Per VHA Directive 2004-038, this routine should not be modified
 Q
 ;
EN(XTMURNAM,XTMUVERB) ; .SR Entry point with primary test routine name, optional 1 for verbose output
 N XTMULIST,XTMUROU,XTMUNIT
 I $G(XTMUVERB)'=1 S XTMUVERB=0
 S XTMULIST=1,XTMUROU(XTMULIST)=XTMURNAM
 D SETUT
 D EN1(.XTMUROU,XTMULIST)
 Q
 ;
SETUT ;
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 S XTMUNIT("IO")=IO,XTMUNIT("DEV")="",XTMUNIT("DEVN")="" F  S XTMUNIT("DEVN")=$O(^TMP("XUDEVICE",$J,XTMUNIT("DEVN"))) Q:XTMUNIT("DEVN")=""  I $G(^(XTMUNIT("DEVN"),"IO"))=IO S XTMUNIT("DEV")=^(0) Q
 I XTMUNIT("DEV")="" S XTMUNIT("DEV")="XTMUNIT DEVICE" D SAVDEV^%ZISUTL(XTMUNIT("DEV"))
 S XTMUNIT=1 ; set to identify unit test being run check with $$ISUTEST^XTMUNIT()
 Q
 ;
EN1(XTMUROU,XTMULIST) ;
 N XTMUERRL,XTMUK,XTMUI,XTMUJ,OLDIO,OLDIOFLG,OLDIONAM,XTMUSTRT
 ; ZEXCEPT: XTMUVERB   -- ARGUMENT TO EN
 ; ZEXCEPT: XTMUGUI      -- CONDITIONALLY DEFINED BY GUINEXT
 ; ZEXCEPT: XTMUNIT  -- NEWED IN EN
 S XTMUNIT("CURR")=0,XTMUNIT("ECNT")=0,XTMUNIT("FAIL")=0,XTMUNIT("CHK")=0,XTMUNIT("NENT")=0,XTMUNIT("ERRN")=0
 ; first get any tree of routines from this one
 D GETTREE(.XTMUROU,.XTMULIST)
 ; 070224 - following code added to allow one overall STARTUP code JLI
 F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D  I $G(XTMUSTRT)'="" D @XTMUSTRT Q
 . I $T(@("STARTUP^"_XTMUROU(XTMUNIT("CURR"))))'="" S XTMUSTRT="STARTUP^"_XTMUROU(XTMUNIT("CURR"))
 . Q
 ; 070224 - end of addition JLI
 ; Now process each routine that has been referenced
 S XTMUNIT("CURR")=0
 F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D
 . ; build a list of entry points for this routine
 . N XTMUETRY S XTMUNIT("ENTN")=0
 . F XTMUI=1:1 S XTMUNIT("ELIN")=$T(@("XTENT+"_XTMUI_"^"_XTMUROU(XTMUNIT("CURR")))) Q:$P(XTMUNIT("ELIN"),";",3)=""  D
 . . S XTMUNIT("ENTN")=XTMUNIT("ENTN")+1,XTMUETRY(XTMUNIT("ENTN"))=$P(XTMUNIT("ELIN"),";",3),XTMUETRY(XTMUNIT("ENTN"),"NAME")=$P(XTMUNIT("ELIN"),";",4)
 . . Q
 . ; if a SETUP entry point exists, do it first
 . S XTMUNIT("LINE")=$T(@("SETUP^"_XTMUROU(XTMUNIT("CURR")))) I XTMUNIT("LINE")'="" D
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT",XTMUNIT("ENT")="SETUP^"_XTMUROU(XTMUNIT("CURR")),XTMUNIT("NAME")="Setup code"
 . . D @("SETUP^"_XTMUROU(XTMUNIT("CURR")))
 . . Q
 . ; run each of the specified entry points
 . S XTMUI=0 F  S XTMUI=$O(XTMUETRY(XTMUI)) Q:XTMUI'>0  S XTMUNIT("ENUM")=XTMUNIT("ERRN")+XTMUNIT("FAIL") D  I XTMUVERB,'$D(XTMUGUI),XTMUNIT("ENUM")=(XTMUNIT("ERRN")+XTMUNIT("FAIL")) D VERBOSE(.XTMUETRY,XTMUI)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
 . . S XTMUNIT("ECNT")=XTMUNIT("ECNT")+1,XTMUNIT("NAME")=XTMUETRY(XTMUI,"NAME"),XTMUNIT("ENT")=XTMUETRY(XTMUI)_"^"_XTMUROU(XTMUNIT("CURR")) D @XTMUNIT("ENT")
 . . Q
 . ; if a TEARDOWN entry point exists, do it before leaving routine
 . S XTMUNIT("LINE")=$T(@("TEARDOWN^"_XTMUROU(XTMUNIT("CURR")))) I XTMUNIT("LINE")'="" D
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT",XTMUNIT("ENT")="TEARDOWN^"_XTMUROU(XTMUNIT("CURR")),XTMUNIT("NAME")="Teardown code"
 . . D @("TEARDOWN^"_XTMUROU(XTMUNIT("CURR")))
 . . Q
 . ; keep a XTMUCNT of number of entry points executed across all routines
 . S XTMUNIT("NENT")=XTMUNIT("NENT")+XTMUNIT("ENTN")
 . Q
 ; 070224 - following code added to allow one overall SHUTDOWN code JLI
 N XTFINISH
 S XTMUNIT("CURR")=0
 F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D  I $G(XTFINISH)'="" D @XTFINISH Q
 . I $T(@("SHUTDOWN^"_XTMUROU(XTMUNIT("CURR"))))'="" S XTFINISH="SHUTDOWN^"_XTMUROU(XTMUNIT("CURR"))
 . Q
 ; 070224 - End of addition JLI
 S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 W !!,"Ran ",XTMULIST," Routine",$S(XTMULIST>1:"s",1:""),", ",XTMUNIT("NENT")," Entry Tag",$S(XTMUNIT("NENT")>1:"s",1:"")
 W !,"Checked ",XTMUNIT("CHK")," test",$S(XTMUNIT("CHK")>1:"s",1:""),", with ",XTMUNIT("FAIL")," failure",$S(XTMUNIT("FAIL")'=1:"s",1:"")," and encountered ",XTMUNIT("ERRN")," error",$S(XTMUNIT("ERRN")'=1:"s",1:""),"."
 I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
 Q
 ; -- end EN1
VERBOSE(XTMUETRY,XTMUI) ;
 N OLDIO,OLDIOFLG,OLDIONAM
 ; ZEXCEPT: XTMUNIT - NEWED IN EN
 S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 W !,"OK - ",XTMUETRY(XTMUI) I $G(XTMUETRY(XTMUI,"NAME"))'="" W " - ",XTMUETRY(XTMUI,"NAME")
 IF OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
 Q
 ;
GETTREE(XTMUROU,XTMULIST) ;
 ; first get any other routines this one references for running subsequently
 ; then any that they refer to as well
 ; this builds a tree of all routines referred to by any routine including each only once
 N XTMUK,XTMUI,XTMUJ,XTMURNAM,XTMURLIN
 F XTMUK=1:1 Q:'$D(XTMUROU(XTMUK))  D
 . F XTMUI=1:1 S XTMURLIN=$T(@("XTROU+"_XTMUI_"^"_XTMUROU(XTMUK))) S XTMURNAM=$P(XTMURLIN,";",3) Q:XTMURNAM=""  D
 . . F XTMUJ=1:1:XTMULIST I XTMUROU(XTMUJ)=XTMURNAM S XTMURNAM="" Q
 . . I XTMURNAM'="",$T(@("+1^"_XTMURNAM))="" W:'$D(XWBOS) "Referenced routine ",XTMURNAM," not found.",! Q
 . . S:XTMURNAM'="" XTMULIST=XTMULIST+1,XTMUROU(XTMULIST)=XTMURNAM
 . . Q
 . Q
 Q
 ;
CHKTF(XTSTVAL,XTERMSG) ; Entry point for checking True or False values
 N OLDIO,OLDIOFLG,OLDIONAM
 ; ZEXCEPT: XTMUERRL,XTMUGUI - CREATED IN SETUP, KILLED IN END
 ; ZEXCEPT: XTMUNIT - NEWED IN EN
 I $G(XTSTVAL)="" D NVLDARG Q
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
 S XTMUNIT("CHK")=$G(XTMUNIT("CHK"))+1
 I '$D(XTMUGUI) D
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 . I 'XTSTVAL W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " D
 . . W XTERMSG,! S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
 . . Q
 . E  W "."
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
 . Q
 I $D(XTMUGUI),'XTSTVAL S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_U_"FAILURE"_U_XTERMSG
 Q
 ;
CHKEQ(XTEXPECT,XTACTUAL,XTERMSG) ; Entry point for checking values to see if they are EQUAL
 N FAILMSG,OLDIO,OLDIOFLG,OLDIONAM
 ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
 ; ZEXCEPT: XTMUNIT  -- NEWED IN EN
 I '$D(XTEXPECT),'$D(XTACTUAL) D NVLDARG Q
 S XTACTUAL=$G(XTACTUAL),XTEXPECT=$G(XTEXPECT)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
 S XTMUNIT("CHK")=XTMUNIT("CHK")+1
 I XTEXPECT'=XTACTUAL S FAILMSG="<"_XTEXPECT_"> vs <"_XTACTUAL_"> - "
 I '$D(XTMUGUI) D
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 . I XTEXPECT'=XTACTUAL W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W FAILMSG,XTERMSG,! D
 . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
 . . Q
 . E  W "."
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
 . Q
 I $D(XTMUGUI),XTEXPECT'=XTACTUAL S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_U_"FAILURE"_U_FAILMSG_XTERMSG
 Q
 ;
FAIL(XTERMSG) ; Entry point for generating a failure message
 N OLDIO,OLDIOFLG,OLDIONAM
 ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
 S XTMUNIT("CHK")=XTMUNIT("CHK")+1
 I '$D(XTMUGUI) D
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 . W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W XTERMSG,! D
 . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
 . . Q
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
 . Q
 I $D(XTMUGUI) S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_U_"FAILURE"_U_XTERMSG
 Q
 ;
CHKLEAKS(XTMUCODE,XTMULOC,XTMUINPT) ; functionality to check for variable leaks on executing a section of code
 ; XTMUCODE - A string that specifies the code that is to be XECUTED and checked for leaks.
 ;            this should be a complete piece of code (e.g., "S X=$$NEW^XLFDT()" or "D EN^XTMUNIT(""ROUNAME"")")
 ; XTMULOC  - A string that is used to indicate the code tested for variable leaks
 ; XTMUINP - An optional variable which may be passed by reference.  This may
 ;           be used to pass any variable values, etc. into the code to be
 ;           XECUTED.  In this case, set the subscript to the variable name and the
 ;           value of the subscripted variable to the desired value of the subscript.
 ;              e.g., (using NAME as my current namespace)
 ;                   S CODE="S XTMUINPT=$$ENTRY^ROUTINE(ZZVALUE1,ZZVALUE2)"
 ;                   S NAMELOC="ENTRY^ROUTINE leak test"   (or simply "ENTRY^ROUTINE")
 ;                   S NAMEINPT("ZZVALUE1")=ZZVALUE1
 ;                   S NAMEINPT("ZZVALUE2")=ZZVALUE2
 ;                   D CHKLEAKS^XTMUNIT(CODE,NAMELOC,.NAMEINPT)
 ;
 ;           If part of a unit test, any leaked variables in ENTRY^ROUTINE which result
 ;           from running the code with the variables indicated will be shown as FAILUREs.
 ;
 ;           If called outside of a unit test, any leaked variables will be printed to the
 ;           current device.
 ;
 ;           If passed by reference the argument XTMUINPT may be used to return values to the
 ;           routine that called CHKLEAKS.
 ;
 N (XTMUCODE,XTMULOC,XTMUINPT,DUZ,IO,U,XTMUERRL,XTMUNIT,XTMUGUI,XTMUI,XTMUJ,XTMUK,XTMULIST,XTMUROU,XTMUSTRT)
 ; ZEXCEPT: XTMUNIT - part of exclusive NEW TESTS FOR EXISTENCE ONLY
 ; ZEXCEPT: XTMUVAR - handled by exclusive NEW
 ;
 ; ACTIVATE ANY VARIABLES PASSED AS SUBSCRIPTS TO XTMUINPT TO THEIR VALUES
 S XTMUVAR=" " F  S XTMUVAR=$O(XTMUINPT(XTMUVAR)) Q:XTMUVAR=""  S (@XTMUVAR)=XTMUINPT(XTMUVAR)
 X XTMUCODE
 N ZZUTVAR S ZZUTVAR="%"
 I $G(XTMUNIT)=1 D
 . I $D(@ZZUTVAR),'$D(XTMUINPT(ZZUTVAR)) D FAIL^XTMUNIT(XTMULOC_" VARIABLE LEAK: "_ZZUTVAR)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,4)'="XTMU",'$D(XTMUINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,"'[(","_ZZUTVAR_",") D FAIL^XTMUNIT(XTMULOC_" VARIABLE LEAK: "_ZZUTVAR)
 . Q
 I '($G(XTMUNIT)=1) D
 . I $D(@ZZUTVAR),'$D(XTMUINPT(ZZUTVAR)) W !,XTMULOC_" VARIABLE LEAK: "_ZZUTVAR
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,4)'="XTMU",'$D(XTMUINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,"'[(","_ZZUTVAR_",") W !,XTMULOC_" VARIABLE LEAK: "_ZZUTVAR
 . Q
 Q
 ;
NVLDARG ; generate message for invalid arguments to test
 N XTERMSG,OLDIO,OLDIOFLG,OLDIONAM
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
 S XTERMSG="NO VALUES INPUT TO CHKEQ^XTMUNIT - no evaluation possible"
 I '$D(XTMUGUI) D
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 . W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W XTERMSG,! D
 . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
 . . Q
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
 . Q
 I $D(XTMUGUI) S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_U_"FAILURE"_U_XTERMSG
 Q
 ;
ERROR ; record errors
 ; ZEXCEPT: XTMUERRL,XTMUGUI,XTMUERR -CREATED IN SETUP, KILLED IN END
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 S XTMUNIT("CHK")=XTMUNIT("CHK")+1
 I '$D(XTMUGUI) D ERROR1
 I $D(XTMUGUI) D
 . S XTMUNIT("CNT")=XTMUNIT("CNT")+1
 . S XTMUERR=XTMUERR+1
 . S @XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_U_"ERROR"_U_$ZE
 . Q
 S $ZE="",$EC=""
 Q
 ;
ERROR1 ;
 N OLDIO,OLDIOFLG,OLDIONAM
 ; ZEXCEPT: XTMUERRL -CREATED IN SETUP, KILLED IN END
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
 I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
 W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - Error: " W $ZE,! D
 . S XTMUNIT("ERRN")=XTMUNIT("ERRN")+1,XTMUERRL(XTMUNIT("ERRN"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=$ZE,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
 . Q
 I IO'=OLDIO D RESETIO(OLDIOFLG,OLDIONAM)
 Q
SETIO(OLDIOFLG,OLDIONAM) ; BOTH PASSED BY REFERENCE
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 N OLDION S OLDION="" F  S OLDION=$O(^TMP("XUDEVICE",$J,OLDION)) Q:OLDION=""  I $G(^(OLDION,"IO"))=IO S OLDIONAM=^(0),OLDIOFLG=1
 I 'OLDIOFLG S OLDIONAM="OLD MUNIT DEV" D SAVDEV^%ZISUTL(OLDIONAM)
 D USE^%ZISUTL(XTMUNIT("DEV"))
 Q
 ;
RESETIO(OLDIOFLG,OLDIONAM) ;
 D USE^%ZISUTL(OLDIONAM) I 'OLDIOFLG D RMDEV^%ZISUTL(OLDIONAM)
 Q
 ;
ISUTEST() ; .SUPPORTED API TO DETERMINE IF CURRENTLY IN UNIT TEST
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
 Q $G(XTMUNIT)=1
 ;
PICKSET ; .OPT Interactive selection of MUnit Test Group
 N DIC,Y,XTMUROU,XTMULIST,DIR
 S DIC=8992.8,DIC(0)="AEQM" D ^DIC Q:Y'>0  W !
 D GETSET(+Y,.XTMUROU,.XTMULIST)
 N DIC,Y,XTMUNIT
 D SETUT
 D EN1(.XTMUROU,XTMULIST)
 S DIR(0)="EA",DIR("A")="Enter RETURN to continue:" D ^DIR K DIR
 Q
 ;
RUNSET(SETNAME) ; .SR Run with Specified Selection of MUnit Test Group
 N Y,XTMUROU,XTMULIST
 Q:$G(SETNAME)=""
 S Y=+$$FIND1^DIC(8992.8,"","X",SETNAME) Q:Y'>0
 D GETSET(Y,.XTMUROU,.XTMULIST)
 N Y,SETNAME,XTMUNIT
 D SETUT
 D EN1(.XTMUROU,XTMULIST)
 Q
 ;
DOSET(IEN) ;
 N XTMUROU,XTMULIST
 S XTMULIST=0
 D GETSET($G(IEN),.XTMUROU,.XTMULIST)
 I XTMULIST>0  N IEN,XTMUNIT D SETUT,EN1(.XTMUROU,XTMULIST)
 Q
 ;
GETSET(IEN,XTMUROU,XTMULIST) ;
 N IENS,XTMROOT
 S IENS=IEN_"," D GETS^DIQ(8992.8,IENS,"1*","","XTMROOT")
 S XTMULIST=0,IENS="" F  S IENS=$O(XTMROOT(8992.81,IENS)) Q:IENS=""  S XTMULIST=XTMULIST+1,XTMUROU(XTMULIST)=XTMROOT(8992.81,IENS,.01)
 Q
 ;
GUISET(XTMURSLT,XTSET) ; Entry point for GUI start with selected Test Set IEN
 N XTMUROU,XTMULIST,XTMUNIT
 D SETUT
 S XTMUNIT("RSLT")=$NA(^TMP("MUNIT-XTMURSLT",$J)) K @XTMUNIT("RSLT")
 D GETSET(XTSET,.XTMUROU,.XTMULIST)
 D GETLIST(.XTMUROU,XTMULIST,XTMUNIT("RSLT"))
 S XTMURSLT=XTMUNIT("RSLT")
 Q
 ;
GUILOAD(XTMURSLT,XTMUROUN) ; Entry point for GUI start with XTMUROUN containing primary routine name
 N XTMUROU,XTMUNIT
 D SETUT
 S XTMUNIT("RSLT")=$NA(^TMP("MUNIT-XTMURSLT",$J)) K @XTMUNIT("RSLT")
 S XTMUROU(1)=XTMUROUN
 D GETLIST(.XTMUROU,1,XTMUNIT("RSLT"))
 S XTMURSLT=XTMUNIT("RSLT")
 Q
 ;
GETLIST(XTMUROU,XTMULIST,XTMURSLT) ;
 N I,XTMUROUL,XTMUROUN,XTMUNIT,XTCOMNT,XTVALUE,XTMUCNT
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J)) K @XTVALUE
 S XTMUCNT=0,XTCOMNT=""
 D GETTREE(.XTMUROU,XTMULIST)
 F I=1:1 Q:'$D(XTMUROU(I))  S XTMUROUL(XTMUROU(I))=""
 S XTMUROUN="" F  S XTMUROUN=$O(XTMUROUL(XTMUROUN)) Q:XTMUROUN=""  D LOAD(XTMUROUN,.XTMUCNT,XTVALUE,XTCOMNT,.XTMUROUL)
 M @XTMURSLT=@XTVALUE
 S @XTVALUE@("LASTROU")="" ; Use this to keep track of place in routines
 Q
 ;
 ; generate list of unit test routines, entry points and comments on test for entry point
LOAD(XTMUROUN,XTMUNCNT,XTVALUE,XTCOMNT,XTMUROUL) ;
 I $T(@("^"_XTMUROUN))="" S XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_"^^*** ERROR - ROUTINE NAME NOT FOUND" Q
 S XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_U_U_XTCOMNT
 N XTMUI,XTX1,XTX2,LINE
 F XTMUI=1:1 S LINE=$T(@("XTENT+"_XTMUI_"^"_XTMUROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTX2=$P(LINE,";",4),XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_U_XTX1_U_XTX2
 F XTMUI=1:1 S LINE=$T(@("XTROU+"_XTMUI_"^"_XTMUROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTCOMNT=$P(LINE,";",4) I '$D(XTMUROUL(XTX1)) S XTMUROUL(XTX1)="" D LOAD(XTX1,.XTMUNCNT,XTVALUE,XTCOMNT,.XTMUROUL)
 Q
 ;
GUINEXT(XTMURSLT,XTMULOC) ; Entry point for GUI execute next test
 N XTMUETRY,XTMUROUT,XTOLROU,XTVALUE,XTMUERR,XTMUGUI
 N XTMUNIT
 D SETUT
 S XTMUNIT("CNT")=0,XTMUNIT("LOC")=XTMULOC
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J))
 S XTMUNIT("RSLT")=$NA(^TMP("GUINEXT",$J)) K @XTMUNIT("RSLT")
 S XTMURSLT=XTMUNIT("RSLT")
 S XTMUETRY=$P(XTMULOC,U),XTMUROUT=$P(XTMULOC,U,2),XTOLROU=$G(@XTVALUE@("LASTROU"))
 S XTMUGUI=1
 I XTMUROUT'=XTOLROU D  I XTMUROUT="" S @XTMURSLT@(1)="" K @XTVALUE Q
 . I XTOLROU'="" I $T(@("TEARDOWN^"_XTOLROU))'="" D
 . . S XTMUNIT("LOC")="TEARDOWN^"_XTMUROUT
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
 . . D @("TEARDOWN^"_XTOLROU)
 . S @XTVALUE@("LASTROU")=XTMUROUT I XTMUROUT'="",$T(@("SETUP^"_XTMUROUT))'="" D
 . . S XTMUNIT("LOC")="SETUP^"_XTMUROUT
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
 . . D @("SETUP^"_XTMUROUT)
 . Q
 S XTMUNIT("LOC")=XTMULOC
 S XTMUNIT("CHK")=0,XTMUNIT("CNT")=1,XTMUERR=0
 D  ; to limit range of error trap so we continue through other tests
 . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
 . D @XTMUNIT("LOC")
 S @XTMUNIT("RSLT")@(1)=XTMUNIT("CHK")_U_(XTMUNIT("CNT")-1-XTMUERR)_U_XTMUERR
 Q
